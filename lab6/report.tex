\documentclass{article}
\usepackage[UTF8]{ctex}
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{mathrsfs,amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{graphicx} %插入图片的宏包
\usepackage{float} %设置图片浮动位置的宏包
\usepackage{subfigure} %插入多图时用子图显示的宏包
\usepackage{parskip}
\usepackage{indentfirst} 
\setlength{\parindent}{2em}
\usepackage{hyperref}  
\usepackage{tikz}
\allowdisplaybreaks
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amsfonts,amssymb} 
\usepackage{xcolor} % 用于显示颜色
\usepackage{listings} % 用于插入代码
\lstset{
	basicstyle          =   \sffamily,          % 基本代码风格
	keywordstyle        =   \bfseries,          % 关键字风格
	commentstyle        =   \rmfamily\itshape,  % 注释的风格，斜体
	stringstyle         =   \ttfamily,  % 字符串风格
	flexiblecolumns,                % 别问为什么，加上这个
	numbers             =   left,   % 行号的位置在左边
	showspaces          =   false,  % 是否显示空格，显示了有点乱，所以不现实了
	numberstyle         =   \zihao{-5}\ttfamily,    % 行号的样式，小五号，tt等宽字体
	showstringspaces    =   false,
	captionpos          =   t,      % 这段代码的名字所呈现的位置，t指的是top上面
	frame               =   lrtb,   % 显示边框
}

\lstdefinestyle{Python}{
	language        =   Python, % 语言选Python
	basicstyle      =   \zihao{-5}\ttfamily,
	numberstyle     =   \zihao{-5}\ttfamily,
	keywordstyle    =   \color{blue},
	keywordstyle    =   [2] \color{teal},
	stringstyle     =   \color{magenta},
	commentstyle    =   \color{red}\ttfamily,
	breaklines      =   true,   % 自动换行，建议不要写太长的行
	columns         =   fixed,  % 如果不加这一句，字间距就不固定，很丑，必须加
	basewidth       =   0.5em,
}

\title{数据结构 Lab-6 实验报告}
\author{林子开 21307110161}
\begin{document}
	\maketitle
	\tableofcontents

\section{算法描述}
% 首先，可以证明在最优的可行安排中，一定存在某个使得各个工作的最晚结束时间递增的安排方案。
% 如果某个安排中，存在工作$a_i$和$a_j$，$a_i$被安排在$a_j$之前，但是对应的最晚结束时间$d_i>d_j$，
% 那么，将工作$a_i$和$a_j$ 的位置，

首先，对工作按照最晚结束时间重新排序，使得对于工作$a_1,a_2,\cdots,a_n$，满足
\[d_1 \le d_2 \le \cdots \le d_n\]

然后，定义$G(i,j)$为在时间$j$之内，从工作$a_1,a_2,\cdots,a_i$中选取\textbf{满足约束条件}的工作，所能得到的\textbf{最大的收益}。
注意到每一项工作最多工作的时间为$n$，完成$n$项工作最多需要的时间是$n^2$，因此最终要求的总收益即为$G(n,n^2)$。
根据题意，$G(i,j)$满足以下的递推关系：

   \[ y=
    \begin{cases}
        0 & \quad \text{if } i=0 \text{ or } j=0 \\
        G(i,d_i) &\quad  \text{if } j>d_i \\
        \mathop{\max}\left\{ G(i-1,j), G(i-1,j-t_i)+p_i \right\} & \quad \text{if } j\le d_i \text{ and } j-t_i \ge 0 \\
        G(i-1,j) & \quad \text{if } j\le d_i \text{ and } j-t_i < 0 
    \end{cases} \]

对上述递推关系的解释如下：

\begin{itemize}

\item 若$i=0$，则说明没有任何工作可选，此时收益显然为0。若$j=0$，则说明此时没有任何时间可以使用，则收益也显然为0。

\item 若$j>d_i$，注意到$d_i$是$a_1,a_2,\cdots,a_n$中允许最晚结束的工作的结束时间，当$j>d_i$时，其实在时间区间
$(d_i,j]$中，已经不可能分配任何工作，因此能够得到的最大收益等于在时间区间$[0,d_i]$中安排工作所能得到的最大收益。

\item 若$j\le d_i \text,\, j-t_i \ge 0$，此时总的时间$j$大于进行允许最晚结束的工作的耗时$t_i$，
此时有两种选择：第一，可以选择做结束时间（$d_i$）最晚的工作$a_i$，此时得到的最大
收益为$G(i-1,j-t_i)+p_i$，其中$p_i$是做工作$a_i$所得到的收益，$G(i-1,j-t_i)$是让$a_i$压线完成后（即$a_i$恰好在$j$时刻完成），
把剩余的时间区间$[0,j-t_i]$分配给剩下的$a_1,a_2,\cdots,a_{i-1}$任务所能得到的最大收益。
第二，也可以选择不做结束时间（$d_i$）最晚的工作$a_i$，直接把时间区间$[0,j]$分配给前$i-1$项任务，
此时的最大收益就是$G(i-1,j)$。从以上两种中选择收益较大者，即为$G(i,j)$。

\item 若$j\le d_i,\, j-t_i < 0 $，此时总的时间$j$小于进行允许最晚结束的工作的耗时$t_i$，则仍然只能从$a_1,a_2,\cdots,a_{i-1}$
之中选择，因此有$G(i,j)=G(i-1,j)$。

\end{itemize}

注意到递推关系中存在大量的重复计算，因此可以用\textbf{动态规划}进行求解。
构建两张$(n+1)\times(n^2+1)$的辅助表，分别为\texttt{G}和\texttt{Action}，其中\texttt{G}存储最优收益，
第$i$行第$j$列恰为上面所定义的$G(i,j)$。
\texttt{Action}存储转移关系，在第$i$行，第$j$列，存储三元组$(u,v,a)$，其中，若在计算$G(i,j)$时，
选择了执行工作$a_i$，则把三元组中的$a$设置为$a_i$，否则设置为NULL；而计算$G(i,j)$时，如果引用了
第$u_0$行第$v_0$列的$G(u_0,v_0)$，则将三元组的前两个元素设置为$u_0$和$v_0$。

在最后，只需要从表格\texttt{Action}的最后一个三元组出发，根据转移函数走到表格的边界，并且一路记录所有的不等于NULL的$a$，
即可得到最优的安排方案。而最大收益即为表格\texttt{G}中的$G(n,n^2)$。



\section{复杂度分析}
\paragraph{空间复杂度}
由于需要额外建立两张$(n+1)\times(n^2+1)$的辅助表格，分别用于存储局部的最优值和转移关系，
因此，空间复杂度为$\mathcal{O}(n^3)$。 

\paragraph{时间复杂度}
在算法执行的过程中，首先要对$n$项工作按照deadline进行升序排序，该步骤复杂度为$\mathcal{O}(n\log(n))$；
然后，要向两张复杂度为$\mathcal{O}(n^3)$的表格填入有关数据，对于表格中
每一个位置，运算复杂度为$\mathcal{O}(1)$，则填写表格时间复杂度也为$\mathcal{O}(n^3)$。综合考虑，
该算法的时间复杂度为$\mathcal{O}(n^3)$。

\section{测试用例的实验结果}
测试用例的实验结果如下：
\begin{enumerate}
	\item 对于工作$[(2, 60, 3), (1, 100, 2), (3, 20, 4), (2, 40, 4)]$，最大的收益为\textbf{160.0}，获得最大收益的工作安排方
	式为$[(1, 100, 2), (2, 60, 3)]$
	
	 \item 对于工作$[(3, 100, 4), (1, 80, 1), (2, 70, 2), (1, 10, 3)]$，最大的收益为\textbf{180.0}，获得最大收益的工作安排方
	式为$[(1, 80, 1), (3, 100, 4)]$
	
	 \item 对于工作$[(4, 100, 4), (2, 75, 3), (3, 50, 3), (1, 25, 1)]$，最大的收益为\textbf{100.0}，获得最大收益的工作安排方
	式为$[(1, 25, 1), (2, 75, 3)]$
	
	 \item 对于工作$[(2, 60, 3), (1, 100, 2), (3, 20, 3), (2, 40, 2), (2, 50, 3)]$，最大的收益为\textbf{160.0}，获得最大收益
	的工作安排方式为$[(1, 100, 2), (2, 60, 3)]$
	
	 \item 对于工作$[(2, 60, 3), (1, 100, 2), (3, 20, 4), (2, 40, 4), (2, 50, 3), (1, 80, 2)]$，最大的收益为\textbf{220.0}，
	获得最大收益的工作安排方式为$[(1, 100, 2), (1, 80, 2), (2, 40, 4)]$
	
	 \item 对于工作$[(2, 60, 3), (1, 100, 2), (3, 20, 3), (2, 40, 2), (2, 50, 3), (1, 80, 2), (4, 90, 4)]$，最大的 
	收益为\textbf{180.0}，获得最大收益的工作安排方式为$[(1, 100, 2), (1, 80, 2)]$
	
	 \item 对于工作$[(3, 60, 3), (2, 100, 2), (1, 20, 2), (2, 40, 4), (4, 50, 4)]$，最大的收益为\textbf{140.0}，获得最大收益
	的工作安排方式为$[(2, 100, 2), (2, 40, 4)]$
	
	 \item 对于工作$[(2, 60, 3), (1, 100, 2), (3, 20, 3), (2, 40, 2), (4, 50, 4), (1, 80, 2), (4, 90, 4)]$，最大的 
	收益为\textbf{180.0}，获得最大收益的工作安排方式为$[(1, 100, 2), (1, 80, 2)]$
	
	 \item 对于工作$[(3, 60, 3), (2, 100, 2), (1, 20, 2), (2, 40, 2), (4, 50, 4), (5, 70, 5)]$，最大的收益为\textbf{100.0}，
	获得最大收益的工作安排方式为$[(2, 100, 2)]$
	
	 \item 对于工作$[(2, 60, 3), (1, 100, 2), (3, 20, 3), (2, 40, 2), (4, 50, 4), (5, 70, 5), (3, 90, 4)]$，最大的 
	收益为\textbf{190.0}，获得最大收益的工作安排方式为$[(1, 100, 2), (3, 90, 4)]$
   \end{enumerate}


\section{附录：本次实验所使用的Python代码}
本次使用的Python代码如下所示
\lstinputlisting[style = Python,
caption={Python codes for scheduling},
label = {schedule}]{find_schedule.py} 

\end{document}

% \begin{figure}[H]
% 	\centering
% 	{\includegraphics[width=0.35\textwidth]{image//ignorance.png}} 
% 	\caption{} \label{} 
% \end{figure}


% \lstinputlisting[style = Python,
% caption={Python codes},
% label = {efficient},
% linerange={110-125}]{exercise3.py} 


% \begin{figure}[H]
%     \centering
%     \subfigure[patch size = 11]
%     {\label{} \includegraphics[width=0.49\textwidth]{image//local equalization with patch size = 11.jpg}}
%     \,    
%     \subfigure[patch size = 51]
%     {\label{} \includegraphics[width=0.49\textwidth]{image//local equalization with patch size = 51.jpg}}
%     \,
%     \subfigure[patch size = 151]
%     {\label{} \includegraphics[width=0.49\textwidth]{image//local equalization with patch size = 151.jpg}}
%     \,    
%     \subfigure[patch size = 201]
%     {\label{} \includegraphics[width=0.49\textwidth]{image//local equalization with patch size = 201.jpg}}
%     \caption{local equalization with different patch sizes}\label{} 
% \end{figure}
